#### 基本概述
1. JS是单线程的语言，同一时间只能执行一个代码块（任务）。

2. 任务可以分为两种：同步任务和异步任务。
    - 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务。
    - 异步任务：不进入主线程，而是进入“任务队列（task queue）”，只有“任务队列”通知主线
程，某个程序可以执行了，该任务才回进入主线程执行。

3. 异步执行的运行机制
    1. 主线程中——执行所有的同步任务，执行到异步任务时将其挂起，继续执行下面的任务。
    2. 任务队列中——当被挂起的异步任务有了结果便会向“任务队列”中放置一个事件。
    3. 当主线程的任务全部执行完毕之后，检查任务队列，并将检查到的事件放入主线程执行。
    4. 循环执行以上三步。

4. 只要主线程空了就会去读取“任务队列”
5. 宏任务与微任务
    - 同样是任务队列中排队的异步任务，执行顺序却有差别。
    - 微任务会优先于宏任务执行，当微任务队列为空时在执行宏任务。

> 微任务

任务名 | 浏览器 | Node
---|---|---
process.nextTick | × | √
MutationObserver | √ | ×
Promise.then/catch/finally | √ | √

> 宏任务

任务名 | 浏览器 | Node
---|---|---
I/O | √ | √
setTimeout | √ | √
setInterval | √ | √
setImmediate | × | √
requestAnimationFrame | √ | ×

> requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行

#### 关于异步任务的执行时间
异步任务通常是注册一个回调函数，等条件完成时执行。而监控这个条件是否完成的地方是在任务队列中。

如：setTimeout的倒数计时，ajax发起的网络请求等，都是在任务队列中进行倒计时和请求的，等倒计时（请求）结束再向主进程传递之前传入异步函数的**回调函数**

```
function fib(n){
    if(n==1||n==2){
        return 1;
    }
    return fib(n-1)+fib(n-2);
}

var p3 = new Promise( function(resolve,reject){
    var t1 = Date.now() // t1: setTimeout 放入异步任务队列的时间
    setTimeout(()=>{
        var t3 = Date.now() // t3: setTimeout内回调函数开始执行的时间
        console.log(t3-t1, t3-t2) // 结束时间-放入时间：37486 结束时间-取出时间：31
        resolve("完成")
    },10000)
})

var t4 = Date.now() // 阻塞开始时间

fib(25); // 使用斐波拉契数列阻塞进程

var t2 = Date.now() // 阻塞结束时间（从任务队列中取出时间）
console.log(t2-t4) // 阻塞时间：37451
```
从上面的代码可以看出，结束时间-取出时间 << 倒计时时间（10000）所以倒计时不可能是取出之后执行的，只能是放入后和斐波拉契函数同步执行的。
可以尝试将fib函数的参数变小，使阻塞时间小于十秒，可以观察到结束时间-放入时间始终大致等于十秒。